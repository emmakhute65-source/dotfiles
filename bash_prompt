# Prompt ideas freely used and stolen from:
# ---
# * http://blog.bigdinosaur.org/easy-ps1-colors/
# * https://github.com/eprev/dotfiles/blob/master/includes/prompt.bash
# * http://www.calmar.ws/vim/256-xterm-24bit-rgb-color-chart.html
# * https://github.com/mathiasbynens/dotfiles/blob/master/.bash_prompt
# * https://github.com/sindresorhus/pure
# * http://ebeab.com/2014/04/17/the-bash-prompt/
#
# Color   | Escape | Code       | tput-8    | tput-256
# --------+--------+------------+-----------+----------
# Black   | 30m    | \033[0;30m | tput 0    | tput 236
# Red     | 31m    | \033[0;31m | tput 1    | tput 196
# Green   | 32m    | \033[0;32m | tput 2    | tput 118
# Yellow  | 33m    | \033[0;33m | tput 3    | tput 226
# Blue    | 34m    | \033[0;34m | tput 4    | tput 69
# Magenta | 35m    | \033[0;35m | tput 5    | tput 135
# Cyan    | 36m    | \033[0;36m | tput 6    | tput 75
# White   | 37m    | \033[0;37m | tput 7    | tput 254
# Reset   | 0      | \033[00m   | tput sgr0 | tput sgr0
# Bold    | 1      | \033[1;xxm | tput bold | tput bold
#

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    *color*) color_prompt=yes;;
    rxvt-unicode) color_prompt=yes;;
esac

if [[ "$color_prompt" == "yes" ]]; then
  # If we've got tput, use it
  if tput colors &> /dev/null; then
    BLACK=$(tput setaf 0)
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    WHITE=$(tput setaf 7)

    BRIGHT=$(tput bold)
    RESET=$(tput sgr0)
    BLINK=$(tput blink)
    REVERSE=$(tput smso)
    UNDERLINE=$(tput smul)

    PURPLE=$(tput setaf 5)
    ORANGE=$(tput setaf 1)
    LIME_YELLOW=$(tput setaf 2)
    POWDER_BLUE=$(tput setaf 4)

    # If we've got >= 256 colors, use em
    if (( $(tput colors) >= 256 )); then
      GREEN=$(tput setaf 190)
      MAGENTA=$(tput setaf 9)
      ORANGE=$(tput setaf 172)
      PURPLE=$(tput setaf 141)
      WHITE=$(tput setaf 254)
      LIME_YELLOW=$(tput setaf 190)
      POWDER_BLUE=$(tput setaf 153)
    fi
  fi
# We're probably in a TTY with 8 colors
else
  BLACK="\033[0;30m"
  RED="\033[0;31m"
  GREEN="\033[0;32m"
  YELLOW="\033[0;33m"
  BLUE="\033[0;34m"
  MAGENTA="\033[0;35m"
  CYAN="\033[0;36m"
  WHITE="\033[0;37m"

  RESET="\033[00m"
  BRIGHT=""

  ORANGE="\033[1;31m"
  PURPLE="\033[1;35m"
  LIME_YELLOW="\033[1;32m"
  POWDER_BLUE="\033[1;34m"
fi

_parse_svn_dirty () {
  if [[ ($(svn st 2> /dev/null) == "") || ($(svn st 2> /dev/null | wc -l) == 1 && $(svn st 2> /dev/null | sed -e 's/\s*\(.\)\s*.*/\1/') == 'S') ]]; then
    printf "${LIME_YELLOW}✔${RESET}"
  else
    printf "${RED}✗${RESET}"
  fi
}

_parse_svn_branch() {
  svn info 2> /dev/null || return
  svn info 2> /dev/null | grep -i url | sed -e "s/url: $REPO\/\(.*\)/ \1[svn]$(_parse_svn_dirty)/i"
}

_parse_git_dirty() {
  if [[ -z "$(git status -s 2> /dev/null)" ]]; then
    printf "${LIME_YELLOW}✔${RESET}"
  else
    printf "${RED}✗${RESET}"
  fi
}

_parse_git_branch() {
  git rev-parse --is-inside-work-tree &>/dev/null || return
  printf " $(git rev-parse --abbrev-ref HEAD)[git]$(_parse_git_dirty)"
}

_rprompt() {
  local _time=$1
  (( $_time < 5 )) && return
  local _out
  local days=$(( $_time / 60 / 60 / 24 ))
  local hours=$(( $_time / 60 / 60 % 24 ))
  local minutes=$(( $_time / 60 % 60 ))
  local seconds=$(( $_time % 60 ))
  (( $days > 0 )) && _out="${days}d"
  (( $hours > 0 )) && _out="$_out ${hours}h"
  (( $minutes > 0 )) && _out="$_out ${minutes}m"
  _out="$_out ${seconds}s"
  printf "${RED}$_out${RESET}"
}

prompt() {
    local _exitcode=$?

    local _end_time=$(date +%s)
    local _total_time=$(( _end_time - _start_time ));
    if ((_end_time == _start_time || _start_time == 0)); then
      _total_time=0
    fi

    unset _start_time

    if [ $_exitcode -eq 0 ]; then
      color=${CYAN}
    else
      color=${RED}
    fi

    _top_row="\[${LIME_YELLOW}\]\W\[${RESET}\]$(_parse_git_branch)$(_parse_svn_branch)\[${RESET}\]"
    [[ "$SSH_CONNECTION" != '' ]] && \
      _top_row="\[${BRIGHT}${MAGENTA}\]\u\[${RESET}\]@\[${ORANGE}\]\h\[${RESET}\]:${_top_row}"

    _bottom_row="\[${color}\]❯\[${RESET}\] "

    PS1="${_top_row}\$(_rprompt $_total_time)\n${_bottom_row}"
}

_log_start() {
  [ -n "$COMP_LINE" ] && return  # do nothing if completing
  [[ "$BASH_COMMAND" == "$PROMPT_COMMAND" || "$BASH_COMMAND" =~ "_rprompt" ]] && return # don't cause a preexec for $PROMPT_COMMAND
  _start_time=$(date +%s)
}

trap '_log_start' DEBUG
PROMPT_COMMAND=prompt
PS2="\[$ORANGE\]→ \[$RESET\]"
