# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}

# All the dig info
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}

# Simple calculator
function calc() {
    local result=""
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//'   # remove trailing zeros
    else
        printf "$result"
    fi
    printf "\n"
}

findalias () {
    unset file
    grep -HiERn "alias ${1}=.*" /etc/bashrc ~/.${MYSHELL}rc $HOME/.exports $HOME/.aliases $HOME/.functions $HOME/.extra 
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Display image with tput
function image() {
    convert $1 -resize 40 txt:-|sed -E 's/://;s/\( ? ?//;s/, ? ?/,/g;s/\)//;s/([0-9]+,[0-9]+,[0-9]+),[0-9]+/\1/g;s/255/254/g;/mage/d'|awk '{print $1,$2}'|sed -E 's/^0,[0-9]+ /print "echo;tput setaf "\;/;s/^[0-9]+,[0-9]+ /print "tput setaf ";/;s/(.+),(.+),(.+)/\1\/42.5*36+\2\/42.5*6+\3\/42.5+16/'|bc|sed 's/$/;echo -n "  ";/'|tr '\n' ' '|sed 's/^/tput rev;/;s/; /;/g;s/$/tput sgr0;echo/'|bash
}

# Pengwynn gxpr https://raw.github.com/pengwynn/dotfiles/ba9efd3d3073314d52d891e9f32b2ca6d26d5d3a/bin/gxpr
# Usage: gxpr <expression>
# Like expr(1), but uses Google's calculator to evaluate <expression>.
#
# Math examples:
#   $ gxpr '1 + 1'
#   2
#
#   $ gxpr 2 ^  16
#   65536
#
#   $ gxpr '(2 ^ 1) + (2 ^ 2) + (2 ^ 3) + (2 ^ 5)'
#   46
#
#   $ gxpr '5*9+(sqrt 10)^3='
#   76.6227766
#
# Conversion examples:
#   $ gxpr 1GB in KB
#   1048576 kilobytes
#
#   $ gxpr 10 megabits in megabytes
#   1.25 megabytes
#
#   $ gxpr 2 miles in inches
#   126720 inches

function gxpr() {
    local CURL_PATH=$(which curl)
    local CURL="$CURL_PATH -s --header 'User-Agent:gxpr/1.0'"
    local SEARCH="http://www.google.com/search"
    local EXPR=$(echo "$@" | sed -e 's/+/%2B/g' -e 's/ /+/g')
    local PAGE=$(curl -s --header 'User-Agent:gxpr/1.0' "http://www.google.com/search?q=$EXPR")

    res=$(
        echo $PAGE |
        perl -ne '/<h2 class="r".*?>(.*)<\/h2>/ and print $1' |
        perl -ne '/= (.*)/ and print $1' |
            perl -pe 's/[^\x00-\x7F]//g'
    )

    # if we don't have a result, assume it's an invalid expression
    test -z "$res" && {
        echo "invalid expression:" "$@" 1>&2
    }

    echo "$res"
}

# http://jeroenjanssens.com/2013/08/16/quickly-navigate-your-filesystem-from-the-command-line.html
jump () { 
    cd -P "$MARKPATH/$1" 2>/dev/null || echo "No such mark: $1"
}

mark() { 
    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"
}

unmark() { 
    rm -i "$MARKPATH/$1"
}

marks() {
    ls -l "$MARKPATH" | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' && echo
}

# autocomplete marks
_completemarks() {
      reply=($(ls $MARKPATH))
}

compctl -K _completemarks jump
compctl -K _completemarks unmark

alias mountainking="osascript -e 'say \"Dum dum dum dum dum dum dum he he he ho ho ho fa lah lah lah lah lah lah fa lah full hoo hoo hoo\" using \"Cellos\"'"
