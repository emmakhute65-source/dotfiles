# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}

# All the dig info
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}

# Simple calculator
function calc() {
    local result=""
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//'   # remove trailing zeros
    else
        printf "$result"
    fi
    printf "\n"
}

findalias () {
    unset file
    grep -HiERn "alias ${1}=.*" /etc/bashrc ~/.${MYSHELL}rc $HOME/.exports $HOME/.aliases $HOME/.functions $HOME/.extra 
}

### User functions ###
extract () {
     if [ -f $1 ] ; then
         case $1 in
             *.tar.bz2)   tar xjf $1        ;;
             *.tar.gz)    tar xzf $1     ;;
             *.bz2)       bunzip2 $1       ;;
             *.rar)       rar x $1     ;;
             *.gz)        gunzip $1     ;;
             *.tar)       tar xf $1        ;;
             *.tbz2)      tar xjf $1      ;;
             *.tgz)       tar xzf $1       ;;
             *.zip)       unzip $1     ;;
             *.Z)         uncompress $1  ;;
             *.7z)        7z x $1    ;;
             *)           echo "'$1' cannot be extracted via extract()" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

g() {
  if [ $# -gt 0 ]; then
    git "$@"
  else
    git hist2
  fi
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Display image with tput
function image() {
    convert $1 -resize 40 txt:-|sed -E 's/://;s/\( ? ?//;s/, ? ?/,/g;s/\)//;s/([0-9]+,[0-9]+,[0-9]+),[0-9]+/\1/g;s/255/254/g;/mage/d'|awk '{print $1,$2}'|sed -E 's/^0,[0-9]+ /print "echo;tput setaf "\;/;s/^[0-9]+,[0-9]+ /print "tput setaf ";/;s/(.+),(.+),(.+)/\1\/42.5*36+\2\/42.5*6+\3\/42.5+16/'|bc|sed 's/$/;echo -n "  ";/'|tr '\n' ' '|sed 's/^/tput rev;/;s/; /;/g;s/$/tput sgr0;echo/'|bash
}

# Pengwynn gxpr https://raw.github.com/pengwynn/dotfiles/ba9efd3d3073314d52d891e9f32b2ca6d26d5d3a/bin/gxpr
# Usage: gxpr <expression>
# Like expr(1), but uses Google's calculator to evaluate <expression>.
#
# Math examples:
#   $ gxpr '1 + 1'
#   2
#
#   $ gxpr 2 ^  16
#   65536
#
#   $ gxpr '(2 ^ 1) + (2 ^ 2) + (2 ^ 3) + (2 ^ 5)'
#   46
#
#   $ gxpr '5*9+(sqrt 10)^3='
#   76.6227766
#
# Conversion examples:
#   $ gxpr 1GB in KB
#   1048576 kilobytes
#
#   $ gxpr 10 megabits in megabytes
#   1.25 megabytes
#
#   $ gxpr 2 miles in inches
#   126720 inches

function gxpr() {
    local CURL_PATH=$(which curl)
    local CURL="$CURL_PATH -s --header 'User-Agent:gxpr/1.0'"
    local SEARCH="http://www.google.com/search"
    local EXPR=$(echo "$@" | sed -e 's/+/%2B/g' -e 's/ /+/g')
    local PAGE=$(curl -s --header 'User-Agent:gxpr/1.0' "http://www.google.com/search?q=$EXPR")

    res=$(
        echo $PAGE |
        perl -ne '/<h2 class="r".*?>(.*)<\/h2>/ and print $1' |
        perl -ne '/= (.*)/ and print $1' |
            perl -pe 's/[^\x00-\x7F]//g'
    )

    # if we don't have a result, assume it's an invalid expression
    test -z "$res" && {
        echo "invalid expression:" "$@" 1>&2
    }

    echo "$res"
}

running () {
    ps aux | grep -i $1 | grep -v grep
}

gif () {
    local search="$1"
    if [ -z "$search" ]; then
        search='.'
    fi
    local db_path=https://dl.dropboxusercontent.com/u/2372716/gifs/
    files=$(ls "$HOME/Dropbox/Public/gifs/" | grep -iE "$search")

    printf "%s\n" "${files[*]}" | nl
    printf "[ $(tput setaf 2)?$(tput sgr0) ]\tWhat gif you want? "
    read index
    local i=0

    for file in "$files"; do
        i=$(($i + 1))
        if [ $i -eq $index ]; then
            if [ $(uname -s) = 'Linux' ]; then
                echo "${db_path}${file}" | xclip -sel clip
            fi
        fi
    done

    unset files
    unset index
}

# http://jeroenjanssens.com/2013/08/16/quickly-navigate-your-filesystem-from-the-command-line.html
jump () { 
    cd -P "$MARKPATH/$1" 2>/dev/null || echo "No such mark: $1"
}

mark() { 
    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"
}

unmark() { 
    rm -i "$MARKPATH/$1"
}

marks() {
    ls -l "$MARKPATH" | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' && echo
}

# autocomplete marks
if [[ "$SHELL" =~ "zsh" ]]; then
    _completemarks() {
          reply=($(ls $MARKPATH))
    }

    compctl -K _completemarks jump
    compctl -K _completemarks unmark
fi

if [[ "$SHELL" =~ "bash" ]]; then
    _completemarks() {
      local curw=${COMP_WORDS[COMP_CWORD]}
      local wordlist=$(find $MARKPATH -type l -printf "%f\n")
      COMPREPLY=($(compgen -W '${wordlist[@]}' -- "$curw"))
      return 0
    }

    complete -F _completemarks jump unmark
fi
